<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GBIO.jl</title><meta name="title" content="Home · GBIO.jl"/><meta property="og:title" content="Home · GBIO.jl"/><meta property="twitter:title" content="Home · GBIO.jl"/><meta name="description" content="Documentation for GBIO.jl."/><meta property="og:description" content="Documentation for GBIO.jl."/><meta property="twitter:description" content="Documentation for GBIO.jl."/><meta property="og:url" content="https://GenomicBreeding.github.io/GBIO.jl/"/><meta property="twitter:url" content="https://GenomicBreeding.github.io/GBIO.jl/"/><link rel="canonical" href="https://GenomicBreeding.github.io/GBIO.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>GBIO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GBIO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GBIO.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GBIO"><a class="docs-heading-anchor" href="#GBIO">GBIO</a><a id="GBIO-1"></a><a class="docs-heading-anchor-permalink" href="#GBIO" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jeffersonfparil/GBIO.jl">GBIO</a>.</p><ul><li><a href="#GBIO.isfuzzymatch-Tuple{String, String}"><code>GBIO.isfuzzymatch</code></a></li><li><a href="#GBIO.levenshteindistance-Tuple{String, String}"><code>GBIO.levenshteindistance</code></a></li><li><a href="#GBIO.readdelimited-Tuple{Type{GBCore.Phenomes}}"><code>GBIO.readdelimited</code></a></li><li><a href="#GBIO.readdelimited-Tuple{Type{GBCore.Trials}}"><code>GBIO.readdelimited</code></a></li><li><a href="#GBIO.readdelimited-Tuple{Type{GBCore.Genomes}}"><code>GBIO.readdelimited</code></a></li><li><a href="#GBIO.readjld2-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:GBCore.AbstractGB"><code>GBIO.readjld2</code></a></li><li><a href="#GBIO.readvcf-Tuple{}"><code>GBIO.readvcf</code></a></li><li><a href="#GBIO.vcf_chunkify-Tuple{String, Bool, Int64, Int64}"><code>GBIO.vcf_chunkify</code></a></li><li><a href="#GBIO.vcf_count_loci-Tuple{String, Bool}"><code>GBIO.vcf_count_loci</code></a></li><li><a href="#GBIO.vcf_extract_allele_freqs!-Tuple{GBCore.Genomes, Union{Nothing, ProgressMeter.Progress}, Int64, String, Bool, Int64, String, Int64, Vector{String}, String, Int64, String, Vector{String}, Vector{String}}"><code>GBIO.vcf_extract_allele_freqs!</code></a></li><li><a href="#GBIO.vcf_extract_entries_and_formats-Tuple{String, Bool}"><code>GBIO.vcf_extract_entries_and_formats</code></a></li><li><a href="#GBIO.vcf_extract_info-Tuple{String, Bool, String, Vector{String}}"><code>GBIO.vcf_extract_info</code></a></li><li><a href="#GBIO.vcf_instantiate_output-Tuple{String, Bool, Vector{String}, Int64, Int64}"><code>GBIO.vcf_instantiate_output</code></a></li><li><a href="#GBIO.vcf_parse_coordinates-Tuple{Vector{String}, Int64, String, Vector{String}}"><code>GBIO.vcf_parse_coordinates</code></a></li><li><a href="#GBIO.writedelimited-Tuple{GBCore.Phenomes}"><code>GBIO.writedelimited</code></a></li><li><a href="#GBIO.writedelimited-Tuple{GBCore.Trials}"><code>GBIO.writedelimited</code></a></li><li><a href="#GBIO.writedelimited-Tuple{GBCore.Genomes}"><code>GBIO.writedelimited</code></a></li><li><a href="#GBIO.writejld2-Tuple{GBCore.AbstractGB}"><code>GBIO.writejld2</code></a></li><li><a href="#GBIO.writevcf-Tuple{GBCore.Genomes}"><code>GBIO.writevcf</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.isfuzzymatch-Tuple{String, String}" href="#GBIO.isfuzzymatch-Tuple{String, String}"><code>GBIO.isfuzzymatch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isfuzzymatch(a::String, b::String; threshold::Float64=0.3)::Bool</code></pre><p>Determines if two strings approximately match each other using Levenshtein distance.</p><p>The function compares two strings and returns <code>true</code> if they are considered similar enough based on the Levenshtein edit distance and a threshold value. The threshold is applied as a fraction of the length of the shorter string.</p><p><strong>Arguments</strong></p><ul><li><code>a::String</code>: First string to compare</li><li><code>b::String</code>: Second string to compare</li><li><code>threshold::Float64=0.3</code>: Maximum allowed edit distance as a fraction of the shorter string length</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the strings match within the threshold, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isfuzzymatch(&quot;populations&quot;, &quot;populations&quot;)
true

julia&gt; isfuzzymatch(&quot;populations&quot;, &quot;poplation&quot;)
true

julia&gt; isfuzzymatch(&quot;populations&quot;, &quot;entry&quot;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/fuzzy_matching.jl#L56-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.levenshteindistance-Tuple{String, String}" href="#GBIO.levenshteindistance-Tuple{String, String}"><code>GBIO.levenshteindistance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">levenshteindistance(a::String, b::String)::Int64</code></pre><p>Calculate the Levenshtein distance (edit distance) between two strings.</p><p>The Levenshtein distance is a measure of the minimum number of single-character edits  (insertions, deletions, or substitutions) required to change one string into another.</p><p><strong>Arguments</strong></p><ul><li><code>a::String</code>: First input string</li><li><code>b::String</code>: Second input string</li></ul><p><strong>Returns</strong></p><ul><li><code>Int64</code>: The minimum number of edits needed to transform string <code>a</code> into string <code>b</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; levenshteindistance(&quot;populations&quot;, &quot;populations&quot;)
0

julia&gt; levenshteindistance(&quot;populations&quot;, &quot;poplation&quot;)
2

julia&gt; levenshteindistance(&quot;populations&quot;, &quot;entry&quot;)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/fuzzy_matching.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.readdelimited-Tuple{Type{GBCore.Genomes}}" href="#GBIO.readdelimited-Tuple{Type{GBCore.Genomes}}"><code>GBIO.readdelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readdelimited(
    type::Type{Genomes};
    fname::String,
    sep::String = &quot;\t&quot;,
    parse_populations_from_entries::Union{Nothing,Function} = nothing,
    verbose::Bool = false
)::Genomes</code></pre><p>Load genotype data from a delimited text file into a <code>Genomes</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>type::Type{Genomes}</code>: Type parameter (always <code>Genomes</code>)</li><li><code>fname::String</code>: Path to the input file</li><li><code>sep::String</code>: Delimiter character (default: tab)</li><li><code>parse_populations_from_entries::Union{Nothing,Function}</code>: Optional function to extract population names from entry names</li><li><code>verbose::Bool</code>: Whether to show progress bar during loading</li></ul><p><strong>File Format</strong></p><p>The input file should be structured as follows:</p><ul><li>Supported extensions: .tsv, .csv, or .txt</li><li>Comments and headers start with &#39;#&#39;</li><li>Header format (2 lines where the second line is optional):<ol><li>Column names: &quot;chrom,pos,all<em>alleles,allele,entry</em>1,entry_2,...&quot;</li><li>Population names (optional): &quot;chrom,pos,all<em>alleles,allele,pop</em>1,pop_2,...&quot;</li></ol></li><li>Data columns:<ol><li>chromosome identifier</li><li>position (integer)</li><li>all alleles at locus (delimited by &#39;|&#39;)</li><li>specific allele</li></ol>5+. allele frequencies for each entry (0.0-1.0 or missing/NA)</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A populated Genomes struct containing the loaded data</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If file doesn&#39;t exist or has invalid format</li><li><code>ArgumentError</code>: If column names don&#39;t match expected format</li><li><code>OverflowError</code>: If allele frequencies are outside [0,1] range</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=10, verbose=false);

julia&gt; genomes.entries = [string(genomes.populations[i], &quot;-&quot;, genomes.entries[i]) for i in eachindex(genomes.populations)];

julia&gt; fname = writedelimited(genomes);

julia&gt; genomes_reloaded = readdelimited(Genomes, fname=fname);

julia&gt; genomes == genomes_reloaded
true

julia&gt; fname = writedelimited(genomes, include_population_header=false);

julia&gt; genomes_reloaded = readdelimited(Genomes, fname=fname);

julia&gt; unique(genomes_reloaded.populations) == [&quot;Unknown_population&quot;]
true

julia&gt; genomes_reloaded = readdelimited(Genomes, fname=fname, parse_populations_from_entries=x -&gt; split(x, &quot;-&quot;)[1]);

julia&gt; genomes == genomes_reloaded
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/tsv.jl#L1-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.readdelimited-Tuple{Type{GBCore.Phenomes}}" href="#GBIO.readdelimited-Tuple{Type{GBCore.Phenomes}}"><code>GBIO.readdelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readdelimited(type::Type{Phenomes}; fname::String, sep::String = &quot;\t&quot;, verbose::Bool = false)::Phenomes</code></pre><p>Load phenotypic data from a delimited text file into a <code>Phenomes</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>type::Type{Phenomes}</code>: Type parameter (must be Phenomes)</li><li><code>fname::String</code>: Path to the input file</li><li><code>sep::String</code>: Delimiter character (default: tab &quot;\t&quot;)</li><li><code>verbose::Bool</code>: Whether to show progress bar during loading (default: false)</li></ul><p><strong>File Format</strong></p><p>The file should be a delimited text file with:</p><ul><li>Header row containing column names</li><li>First column: Entry identifiers</li><li>Second column: Population identifiers </li><li>Remaining columns: Phenotypic trait values (numeric or missing)</li></ul><p>Missing values can be specified as &quot;missing&quot;, &quot;NA&quot;, &quot;na&quot;, &quot;N/A&quot;, &quot;n/a&quot; or empty string.</p><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A Phenomes struct containing the loaded phenotypic data</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If file doesn&#39;t exist or has invalid format</li><li><code>ArgumentError</code>: If required columns are missing or misnamed</li><li><code>ErrorException</code>: If duplicate entries or traits are found</li><li><code>ErrorException</code>: If numeric values cannot be parsed</li></ul><p><strong>Notes</strong></p><ul><li>Comments starting with &#39;#&#39; are ignored</li><li>Empty lines are skipped</li><li>Mathematical operators (+,-,*,/,%) in trait names are replaced with underscores</li><li>Performs dimension checks on the loaded data</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = rand(10,3); phenomes.phenotypes[1,1] = missing; phenomes.mask .= true;

julia&gt; fname = writedelimited(phenomes);

julia&gt; phenomes_reloaded = readdelimited(Phenomes, fname=fname);

julia&gt; phenomes == phenomes_reloaded
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/tsv.jl#L417-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.readdelimited-Tuple{Type{GBCore.Trials}}" href="#GBIO.readdelimited-Tuple{Type{GBCore.Trials}}"><code>GBIO.readdelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readdelimited(type::Type{Trials}; fname::String, sep::String = &quot;\t&quot;, verbose::Bool = false)::Trials</code></pre><p>Load a <code>Trials</code> struct from a string-delimited file.</p><p><strong>Arguments</strong></p><ul><li><code>type::Type{Trials}</code>: Type parameter (must be <code>Trials</code>)</li><li><code>fname::String</code>: Path to the input file</li><li><code>sep::String = &quot;\t&quot;</code>: Delimiter character (default is tab)</li><li><code>verbose::Bool = false</code>: Whether to display progress information</li></ul><p><strong>Required File Structure</strong></p><p>The input file must contain the following 10 identifier columns:</p><ul><li><code>years</code>: Year identifiers</li><li><code>seasons</code>: Season identifiers</li><li><code>harvests</code>: Harvest identifiers</li><li><code>sites</code>: Site identifiers</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population identifiers</li><li><code>replications</code>: Replication identifiers</li><li><code>blocks</code>: Block identifiers</li><li><code>rows</code>: Row identifiers</li><li><code>cols</code>: Column identifiers</li></ul><p>All remaining columns are treated as numeric phenotype measurements. Column names are fuzzy-matched to accommodate slight spelling variations.</p><p><strong>Returns</strong></p><ul><li><code>Trials</code>: A populated Trials struct containing the loaded data</li></ul><p><strong>Notes</strong></p><ul><li>Missing values can be represented as &quot;missing&quot;, &quot;NA&quot;, &quot;na&quot;, &quot;N/A&quot;, &quot;n/a&quot;, or empty strings</li><li>Trait names containing mathematical operators (+, -, *, /, %) are converted to underscores</li><li>Duplicate trait names are not allowed</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If the input file doesn&#39;t exist or has invalid format</li><li><code>ArgumentError</code>: If required columns are missing or ambiguous</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=10, verbose=false);

julia&gt; trials, _ = GBCore.simulatetrials(genomes=genomes, sparsity=0.1, verbose=false);

julia&gt; fname = writedelimited(trials);

julia&gt; trials_reloaded = readdelimited(Trials, fname=fname);

julia&gt; trials == trials_reloaded
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/tsv.jl#L718-L770">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.readjld2-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:GBCore.AbstractGB" href="#GBIO.readjld2-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:GBCore.AbstractGB"><code>GBIO.readjld2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readjld2(type::Type; fname::String)::Type</code></pre><p>Load a core (<code>Genomes</code>, <code>Phenomes</code>, and <code>Trials</code>), simulation (<code>SimulatedEffects</code>), or model (<code>TEBV</code>) struct from a JLD2 file.</p><p><strong>Arguments</strong></p><ul><li><code>type::Type</code>: The type of struct to load (<code>Genomes</code>, <code>Phenomes</code>, <code>Trials</code>, <code>SimulatedEffects</code>, or <code>TEBV</code>)</li><li><code>fname::String</code>: Path to the JLD2 file to read from</li></ul><p><strong>Returns</strong></p><ul><li>The loaded struct of the specified type</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the specified file does not exist</li><li><code>DimensionMismatch</code>: If the loaded struct is corrupted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=2, verbose=false);

julia&gt; fname = writejld2(genomes);

julia&gt; readjld2(Genomes, fname=fname) == genomes
true

julia&gt; phenomes = Phenomes(n=2, t=2); phenomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;]; phenomes.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; fname = writejld2(phenomes);

julia&gt; readjld2(Phenomes, fname=fname) == phenomes
true

julia&gt; trials, _ = simulatetrials(genomes=genomes, verbose=false);

julia&gt; fname = writejld2(trials);

julia&gt; readjld2(Trials, fname=fname) == trials
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/jld2.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.readvcf-Tuple{}" href="#GBIO.readvcf-Tuple{}"><code>GBIO.readvcf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readvcf(; fname::String, field::String = &quot;any&quot;, verbose::Bool = false)::Genomes</code></pre><p>Read genetic data from a VCF (Variant Call Format) file into a Genomes struct.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Path to the VCF file. Can be gzipped (.vcf.gz or .vcf.bgz) or uncompressed (.vcf)</li><li><code>field::String=&quot;any&quot;</code>: Which FORMAT field to extract from VCF. Default &quot;any&quot; tries to automatically detect genotype field</li><li><code>verbose::Bool=false</code>: Whether to print progress and debug information</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A Genomes struct containing the loaded genetic data with fields:<ul><li><code>allele_frequencies</code>: Matrix of allele frequencies</li><li><code>loci_alleles</code>: Vector of locus-allele combination strings</li><li><code>mask</code>: Boolean matrix indicating missing data</li><li><code>samples</code>: Vector of sample names</li></ul></li></ul><p><strong>Details</strong></p><p>Reads VCF files in parallel using multiple threads. Handles multi-allelic variants and different ploidies.  Performs various checks on the input data including:</p><ul><li>File existence</li><li>No duplicate loci-allele combinations </li><li>Consistent dimensions in output struct</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If file doesn&#39;t exist, has duplicates, or output dimensions are invalid</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=10, verbose=false);

julia&gt; fname = writevcf(genomes);

julia&gt; fname_gz = writevcf(genomes, gzip=true);

julia&gt; genomes_reloaded = readvcf(fname=fname);

julia&gt; genomes_reloaded_gz = readvcf(fname=fname_gz);

julia&gt; genomes.entries == genomes_reloaded.entries == genomes_reloaded_gz.entries
true

julia&gt; dimensions(genomes) == dimensions(genomes_reloaded) == dimensions(genomes_reloaded_gz)
true

julia&gt; ismissing.(genomes.allele_frequencies) == ismissing.(genomes_reloaded.allele_frequencies) == ismissing.(genomes_reloaded_gz.allele_frequencies)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/vcf.jl#L634-L682">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.vcf_chunkify-Tuple{String, Bool, Int64, Int64}" href="#GBIO.vcf_chunkify-Tuple{String, Bool, Int64, Int64}"><code>GBIO.vcf_chunkify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcf_chunkify(fname::String, verbose::Bool, n_loci::Int64, line_counter::Int64)::Tuple{Vector{Int64},Vector{Int64},Vector{Int64},Vector{Int64}}</code></pre><p>Divide a VCF file into chunks for parallel processing by determining file positions and loci indexes for each thread.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Path to the VCF file (can be .vcf, .vcf.gz, or .vcf.bgz)</li><li><code>verbose::Bool</code>: If true, prints progress information</li><li><code>n_loci::Int64</code>: Total number of loci in the VCF file</li><li><code>line_counter::Int64</code>: Current line counter position in the file</li></ul><p><strong>Returns</strong></p><p>A tuple containing four Vector{Int64} arrays:</p><ol><li>Starting loci indices for each thread</li><li>Ending loci indices for each thread</li><li>Starting file positions for each thread</li><li>Ending file positions for each thread</li></ol><p><strong>Details</strong></p><ul><li>Automatically detects if the input file is gzipped</li><li>Divides the workload evenly across available threads</li><li>Skips header lines (starting with &#39;#&#39;)</li><li>Handles both regular and gzipped VCF files</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/vcf.jl#L48-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.vcf_count_loci-Tuple{String, Bool}" href="#GBIO.vcf_count_loci-Tuple{String, Bool}"><code>GBIO.vcf_count_loci</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcf_count_loci(fname::String, verbose::Bool)::Tuple{Int64,Int64}</code></pre><p>Count the number of loci and total lines in a VCF file.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Path to the VCF file. Can be either a plain text VCF file or a gzipped VCF file (with extensions .vcf.gz or .vcf.bgz)</li><li><code>verbose::Bool</code>: If true, prints progress messages and results to stdout</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ul><li>First element: Total number of lines in the file (Int64)</li><li>Second element: Number of loci/variants in the file (Int64)</li></ul><p><strong>Description</strong></p><p>This function reads through a VCF file and counts:</p><ol><li>The total number of lines in the file</li><li>The number of data lines (loci/variants) excluding header lines (those starting with &#39;#&#39;)</li></ol><p>The function automatically detects if the file is gzipped based on its extension and handles it appropriately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/vcf.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.vcf_extract_allele_freqs!-Tuple{GBCore.Genomes, Union{Nothing, ProgressMeter.Progress}, Int64, String, Bool, Int64, String, Int64, Vector{String}, String, Int64, String, Vector{String}, Vector{String}}" href="#GBIO.vcf_extract_allele_freqs!-Tuple{GBCore.Genomes, Union{Nothing, ProgressMeter.Progress}, Int64, String, Bool, Int64, String, Int64, Vector{String}, String, Int64, String, Vector{String}, Vector{String}}"><code>GBIO.vcf_extract_allele_freqs!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcf_extract_allele_freqs!(genomes, pb, i, fname, verbose, line_counter, field, idx_field, line, chrom, pos, ref, alt, refalts)</code></pre><p>Extract allele frequencies from VCF file data and update the <code>genomes</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Object storing genomic data and allele frequencies</li><li><code>pb::Union{Nothing,Progress}</code>: Progress bar object for tracking progress</li><li><code>i::Int64</code>: Current index for tracking position in genomic data</li><li><code>fname::String</code>: Name of the VCF file being processed</li><li><code>verbose::Bool</code>: Flag to control progress bar display</li><li><code>line_counter::Int64</code>: Current line number in the VCF file</li><li><code>field::String</code>: Type of field to extract (&quot;AF&quot;, &quot;AD&quot;, or &quot;GT&quot;)</li><li><code>idx_field::Int64</code>: Index of the field in the VCF format</li><li><code>line::Vector{String}</code>: Current line from VCF file split into fields</li><li><code>chrom::String</code>: Chromosome identifier</li><li><code>pos::Int64</code>: Position on chromosome</li><li><code>ref::String</code>: Reference allele</li><li><code>alt::Vector{String}</code>: Alternative alleles</li><li><code>refalts::Vector{String}</code>: Combined vector of reference and alternative alleles</li></ul><p><strong>Returns</strong></p><p>Tuple containing:</p><ul><li>Updated <code>genomes</code> object</li><li>Progress bar object</li><li>Updated index <code>i</code></li></ul><p><strong>Description</strong></p><p>Processes VCF data to extract allele frequencies using one of three methods:</p><ul><li>AF (Allele Frequencies): Direct frequency values</li><li>AD (Allele Depths): Calculated from read depths</li><li>GT (Genotypes): Calculated from genotype calls</li></ul><p>Missing values are handled appropriately for each method. The function updates the <code>genomes.loci_alleles</code> and <code>genomes.allele_frequencies</code> fields with the extracted data.</p><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If unable to parse AF or AD fields</li><li><code>ArgumentError</code>: If an unrecognized field type is specified</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/vcf.jl#L488-L527">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.vcf_extract_entries_and_formats-Tuple{String, Bool}" href="#GBIO.vcf_extract_entries_and_formats-Tuple{String, Bool}"><code>GBIO.vcf_extract_entries_and_formats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcf_extract_entries_and_formats(fname::String, verbose::Bool)::Tuple{Vector{String},Vector{String}}</code></pre><p>Extract sample entries and format definitions from a VCF file.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Path to the VCF file (can be gzipped with extensions .vcf.gz or .vcf.bgz)</li><li><code>verbose::Bool</code>: If true, prints progress information to stdout</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ul><li><code>Vector{String}</code>: List of sample names from the VCF header</li><li><code>Vector{String}</code>: List of FORMAT field definitions from the VCF metadata</li></ul><p><strong>Description</strong></p><p>This function reads a VCF file and extracts:</p><ol><li>The sample names from the header line (columns after the FORMAT field)</li><li>The FORMAT field definitions from the metadata lines starting with &quot;##FORMAT&quot;</li></ol><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the VCF file has fewer than expected columns or if the column names don&#39;t match the expected VCF format</li></ul><p><strong>Note</strong></p><p>The function validates the presence and order of the standard VCF columns: #CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO, and FORMAT</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/vcf.jl#L129-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.vcf_extract_info-Tuple{String, Bool, String, Vector{String}}" href="#GBIO.vcf_extract_info-Tuple{String, Bool, String, Vector{String}}"><code>GBIO.vcf_extract_info</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcf_extract_info(fname::String, verbose::Bool, field::String, format_lines::Vector{String})::Tuple{String,Int64,Int64}</code></pre><p>Extract information about genotype fields from a VCF file.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Path to the VCF file (can be gzipped)</li><li><code>verbose::Bool</code>: If true, prints progress information</li><li><code>field::String</code>: Specific field to extract (&quot;GT&quot;, &quot;AD&quot;, &quot;AF&quot;, or &quot;any&quot;)</li><li><code>format_lines::Vector{String}</code>: Vector containing FORMAT lines from the VCF header</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ol><li><code>field::String</code>: The identified genotype field</li><li><code>n_alleles::Int64</code>: Maximum number of alleles per locus</li><li><code>ploidy::Int64</code>: Ploidy level (only meaningful for GT field)</li></ol><p><strong>Details</strong></p><ul><li>If <code>field</code> is &quot;any&quot;, searches for fields in priority order: AF &gt; AD &gt; GT</li><li>For GT field, scans entire file to determine maximum number of alleles and ploidy</li><li>For AF and AD fields, extracts allele count from format header</li><li>Supports both gzipped (.gz, .bgz) and uncompressed VCF files</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If specified field is not found in the VCF file</li><li><code>ErrorException</code>: If unable to parse number of alleles from format header</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/vcf.jl#L225-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.vcf_instantiate_output-Tuple{String, Bool, Vector{String}, Int64, Int64}" href="#GBIO.vcf_instantiate_output-Tuple{String, Bool, Vector{String}, Int64, Int64}"><code>GBIO.vcf_instantiate_output</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcf_instantiate_output(fname::String, verbose::Bool, entries::Vector{String}, n_loci::Int64, n_alleles::Int64)::Genomes</code></pre><p>Create and initialize a Genomes struct from VCF file parameters.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Name of the VCF file being processed</li><li><code>verbose::Bool</code>: If true, prints progress information</li><li><code>entries::Vector{String}</code>: Vector containing entry identifiers</li><li><code>n_loci::Int64</code>: Number of loci in the VCF file</li><li><code>n_alleles::Int64</code>: Number of alleles per locus</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: An initialized Genomes struct with:<ul><li>dimensions n × p where n is number of entries and p = n<em>loci * (n</em>alleles - 1)</li><li>entry names assigned</li><li>populations set to &quot;unknown&quot;</li><li>mask set to true</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If duplicate entries are found in the VCF file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/vcf.jl#L344-L365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.vcf_parse_coordinates-Tuple{Vector{String}, Int64, String, Vector{String}}" href="#GBIO.vcf_parse_coordinates-Tuple{Vector{String}, Int64, String, Vector{String}}"><code>GBIO.vcf_parse_coordinates</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcf_parse_coordinates(line::Vector{String}, line_counter::Int64, field::String, entries::Vector{String})::Union{Nothing,Tuple{Int64,String,Int64,String,Vector{String},Vector{String}}}</code></pre><p>Parse coordinates and allele information from a VCF file line.</p><p><strong>Arguments</strong></p><ul><li><code>line::Vector{String}</code>: A vector containing the split line from VCF file</li><li><code>line_counter::Int64</code>: Current line number being processed in the VCF file</li><li><code>field::String</code>: The field name to extract allele frequencies from</li><li><code>entries::Vector{String}</code>: Vector of sample entries from the VCF header</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: If the specified field is not found in the line</li><li><code>Tuple{Int64,String,Int64,String,Vector{String},Vector{String}}</code>: A tuple containing:<ul><li>Field index</li><li>Chromosome name</li><li>Position</li><li>Reference allele</li><li>Alternative alleles</li><li>Combined reference and alternative alleles</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If the number of columns doesn&#39;t match the header</li><li><code>ErrorException</code>: If the position field cannot be parsed as an integer</li></ul><p><strong>Note</strong></p><p>The function validates the line format and extracts genomic coordinates and allele information from a VCF file line. It handles missing alternative alleles (denoted by &quot;.&quot;) and performs necessary type conversions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/vcf.jl#L406-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.writedelimited-Tuple{GBCore.Genomes}" href="#GBIO.writedelimited-Tuple{GBCore.Genomes}"><code>GBIO.writedelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writedelimited(
    genomes::Genomes;
    fname::Union{Missing,String} = missing,
    sep::String = &quot;\t&quot;,
    include_population_header::Bool = true
)::String</code></pre><p>Write genomic data to a delimited text file.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes struct containing the genomic data to be written</li><li><code>fname::Union{Missing,String}</code>: Output filename. If missing, generates an automatic filename with timestamp</li><li><code>sep::String</code>: Delimiter character for the output file (default: tab)</li><li><code>include_population_header::Bool</code>: Whether to include population information in the header (default: true)</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the created output file</li></ul><p><strong>File Format</strong></p><p>The output file contains:</p><ol><li>Header lines (prefixed with &#39;#&#39;):<ul><li>First line: chromosome, position, alleles, and entry information</li><li>Second line (optional): population information</li></ul></li><li>Data rows with the following columns:<ul><li>Column 1: Chromosome identifier</li><li>Column 2: Position</li><li>Column 3: All alleles at the locus (pipe-separated)</li><li>Column 4: Specific allele</li><li>Remaining columns: Frequency data for each entry</li></ul></li></ol><p><strong>Supported File Extensions</strong></p><ul><li>&#39;.tsv&#39; (tab-separated, default)</li><li>&#39;.csv&#39; (comma-separated)</li><li>&#39;.txt&#39; (custom delimiter)</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the input Genomes struct is corrupted</li><li><code>ErrorException</code>: If the output file already exists</li><li><code>ArgumentError</code>: If the file extension is invalid or the output directory doesn&#39;t exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=2, verbose=false);

julia&gt; writedelimited(genomes, fname=&quot;test_genomes.tsv&quot;)
&quot;test_genomes.tsv&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/tsv.jl#L310-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.writedelimited-Tuple{GBCore.Phenomes}" href="#GBIO.writedelimited-Tuple{GBCore.Phenomes}"><code>GBIO.writedelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writedelimited(phenomes::Phenomes; fname::Union{Missing,String} = missing, sep::String = &quot;	&quot;)::String</code></pre><p>Write phenotypic data from a <code>Phenomes</code> struct to a delimited text file.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A Phenomes struct containing phenotypic data</li><li><code>fname::Union{Missing,String} = missing</code>: Output filename. If missing, generates an automatic filename with timestamp</li><li><code>sep::String = &quot;	&quot;</code>: Delimiter character for the output file</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The name of the created file</li></ul><p><strong>File Format</strong></p><ul><li>Header line starts with &#39;#&#39; containing column names</li><li>First column: Entry names</li><li>Second column: Population names</li><li>Remaining columns: Trait values</li><li>Missing values are represented as &quot;NA&quot;</li></ul><p><strong>File Extensions</strong></p><p>Supported file extensions:</p><ul><li><code>.tsv</code> for tab-separated files (default)</li><li><code>.csv</code> for comma-separated files</li><li><code>.txt</code> for other delimiters</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the Phenomes struct dimensions are inconsistent</li><li><code>ErrorException</code>: If the output file already exists</li><li><code>ArgumentError</code>: If the file extension is invalid or the directory doesn&#39;t exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=2, t=2); phenomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;]; phenomes.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; writedelimited(phenomes, fname=&quot;test_phenomes.tsv&quot;)
&quot;test_phenomes.tsv&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/tsv.jl#L631-L669">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.writedelimited-Tuple{GBCore.Trials}" href="#GBIO.writedelimited-Tuple{GBCore.Trials}"><code>GBIO.writedelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writedelimited(trials::Trials; fname::Union{Missing,String} = missing, sep::String = &quot;	&quot;)::String</code></pre><p>Write a <code>Trials</code> struct to a delimited text file, returning the filename.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: The trials data structure to be written</li><li><code>fname::Union{Missing,String} = missing</code>: Output filename. If missing, generates automatic filename with timestamp</li><li><code>sep::String = &quot;	&quot;</code>: Delimiter character between fields</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The name of the file that was written</li></ul><p><strong>File Format</strong></p><p>The output file contains one header line and one line per trial entry. Header line is prefixed with &#39;#&#39; and contains column names.</p><p><strong>Fixed Columns (1-10)</strong></p><ol><li>years</li><li>seasons</li><li>harvests</li><li>sites</li><li>entries</li><li>populations</li><li>replications</li><li>blocks</li><li>rows</li><li>cols</li></ol><p><strong>Variable Columns (11+)</strong></p><ul><li>Additional columns contain phenotype traits values</li><li>Missing values are written as &quot;NA&quot;</li></ul><p><strong>Notes</strong></p><ul><li>Supported file extensions: <code>.tsv</code>, <code>.csv</code>, or <code>.txt</code></li><li>File extension is automatically determined based on separator if filename is missing:<ul><li><code>\t</code> → <code>.tsv</code></li><li><code>,</code> or <code>;</code> → <code>.csv</code></li><li>other → <code>.txt</code></li></ul></li><li>Will not overwrite existing files</li><li>Directory must exist if path is specified in filename</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=1, t=2); trials.years = [&quot;year_1&quot;]; trials.seasons = [&quot;season_1&quot;]; trials.harvests = [&quot;harvest_1&quot;]; trials.sites = [&quot;site_1&quot;]; trials.entries = [&quot;entry_1&quot;]; trials.populations = [&quot;population_1&quot;]; trials.replications = [&quot;replication_1&quot;]; trials.blocks = [&quot;block_1&quot;]; trials.rows = [&quot;row_1&quot;]; trials.cols = [&quot;col_1&quot;]; trials.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; writedelimited(trials, fname=&quot;test_trials.tsv&quot;)
&quot;test_trials.tsv&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/tsv.jl#L931-L980">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.writejld2-Tuple{GBCore.AbstractGB}" href="#GBIO.writejld2-Tuple{GBCore.AbstractGB}"><code>GBIO.writejld2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writejld2(A::Union{Genomes,Phenomes,Trials,SimulatedEffects,TEBV}; fname::Union{Missing,String} = missing)::String</code></pre><p>Save genomic breeding core data structures to a JLD2 file (HDF5-compatible format).</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: A genomic breeding data structure (Genomes, Phenomes, Trials, SimulatedEffects, or TEBV)</li><li><code>fname</code>: Optional. Output filename. If missing, generates an automatic name with timestamp</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the saved JLD2 file</li></ul><p><strong>File Naming</strong></p><ul><li>If <code>fname</code> is not provided, generates name: &quot;output-[Type]-[Timestamp].jld2&quot;</li><li>If <code>fname</code> is provided, must have &quot;.jld2&quot; extension</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If input structure has invalid dimensions</li><li><code>ErrorException</code>: If output file already exists</li><li><code>ArgumentError</code>: If invalid file extension or directory path</li></ul><p><strong>Notes</strong></p><ul><li>Files are saved with compression enabled</li><li>Data is stored as a Dictionary with single key-value pair</li><li>Key is the string representation of the input type</li><li>Existing files will not be overwritten</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GBCore.simulategenomes(n=2, verbose=false);

julia&gt; writejld2(genomes, fname=&quot;test_genomes.jld2&quot;)
&quot;test_genomes.jld2&quot;

julia&gt; genomes_reloaded = load(&quot;test_genomes.jld2&quot;);

julia&gt; genomes_reloaded[collect(keys(genomes_reloaded))[1]] == genomes
true

julia&gt; phenomes = Phenomes(n=2, t=2); phenomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;]; phenomes.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; writejld2(phenomes, fname=&quot;test_phenomes.jld2&quot;)
&quot;test_phenomes.jld2&quot;

julia&gt; phenomes_reloaded = load(&quot;test_phenomes.jld2&quot;);

julia&gt; phenomes_reloaded[collect(keys(phenomes_reloaded))[1]] == phenomes
true

julia&gt; trials, _ = simulatetrials(genomes=genomes, verbose=false);

julia&gt; writejld2(trials, fname=&quot;test_trials.jld2&quot;)
&quot;test_trials.jld2&quot;

julia&gt; trials_reloaded = load(&quot;test_trials.jld2&quot;);

julia&gt; trials_reloaded[collect(keys(trials_reloaded))[1]] == trials
true

julia&gt; simulated_effects = SimulatedEffects();

julia&gt; writejld2(simulated_effects, fname=&quot;test_simulated_effects.jld2&quot;)
&quot;test_simulated_effects.jld2&quot;

julia&gt; simulated_effects_reloaded = load(&quot;test_simulated_effects.jld2&quot;);

julia&gt; simulated_effects_reloaded[collect(keys(simulated_effects_reloaded))[1]] == simulated_effects
true

julia&gt; trials, _simulated_effects = GBCore.simulatetrials(genomes = GBCore.simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);

julia&gt; tebv = analyse(trials, max_levels=50, verbose=false);

julia&gt; writejld2(tebv, fname=&quot;test_tebv.jld2&quot;)
&quot;test_tebv.jld2&quot;

julia&gt; tebv_reloaded = load(&quot;test_tebv.jld2&quot;);

julia&gt; tebv_reloaded[collect(keys(tebv_reloaded))[1]] == tebv
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/jld2.jl#L54-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GBIO.writevcf-Tuple{GBCore.Genomes}" href="#GBIO.writevcf-Tuple{GBCore.Genomes}"><code>GBIO.writevcf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writevcf(genomes::Genomes; fname::Union{Missing,String} = missing, ploidy::Int64 = 0, 
         max_depth::Int64 = 100, n_decimal_places::Int64 = 4, gzip::Bool = false)::String</code></pre><p>Write genomic data to a Variant Call Format (VCF) file.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes object containing the genetic data to be written.</li><li><code>fname::Union{Missing,String} = missing</code>: Output filename. If missing, generates a default name with timestamp.</li><li><code>ploidy::Int64 = 0</code>: The ploidy level of the organisms (e.g., 2 for diploid).</li><li><code>max_depth::Int64 = 100</code>: Maximum depth for allele depth calculation.</li><li><code>n_decimal_places::Int64 = 4</code>: Number of decimal places for rounding allele frequencies.</li><li><code>gzip::Bool = false</code>: Whether to compress the output file using gzip.</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The name of the created VCF file.</li></ul><p><strong>Description</strong></p><p>Creates a VCF v4.2 format file containing genomic variants data. The function processes allele frequencies and depths, calculates genotypes based on ploidy, and formats the data according to VCF specifications. The output includes:</p><ul><li>Standard VCF header information</li><li>Sample information with FORMAT fields:<ul><li>GT (Genotype)</li><li>AD (Allele Depth)</li><li>AF (Allele Frequency)</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the input Genomes object has inconsistent dimensions</li><li><code>ErrorException</code>: If the output file already exists</li><li><code>ArgumentError</code>: If the file extension is not &#39;.vcf&#39; or if the specified directory doesn&#39;t exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes_1 = GBCore.simulategenomes(n=2, verbose=false);

julia&gt; writevcf(genomes_1, fname=&quot;test_genomes_1.vcf&quot;)
&quot;test_genomes_1.vcf&quot;

julia&gt; genomes_2 = GBCore.simulategenomes(n=2, n_alleles=3, verbose=false);

julia&gt; genomes_2.allele_frequencies = round.(genomes_2.allele_frequencies .* 4) ./ 4;

julia&gt; writevcf(genomes_2, fname=&quot;test_genomes_2.vcf&quot;, ploidy=4)
&quot;test_genomes_2.vcf&quot;

julia&gt; genomes_3 = GBCore.simulategenomes(n=3, verbose=false);

julia&gt; writevcf(genomes_3, fname=&quot;test_genomes_3.vcf&quot;, gzip=true)
&quot;test_genomes_3.vcf.gz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GBIO.jl/blob/9c8224e3e64967259ce608cf406458bb7102dc54/src/vcf.jl#L822-L873">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Saturday 8 March 2025 04:15">Saturday 8 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
